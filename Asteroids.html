<!DOCTYPE html>
<html>
<head>
	<title>test</title>
</head>
<style type="text/css">
	html, body {
			width: 100%;
			height: 100%;
			margin: 0px;
			overflow: hidden;
	}
	canvas {
		width: 100%;
		height: 100%;
	}
</style>
<body>
<canvas id="canvas" onmousemove="updateMouseCoordinates(event)" onkeypress="keyPressed(event)" onclick="mouseClick()"> </canvas>
<script type="text/javascript">
	canvas = document.getElementById("canvas");
	ctx = canvas.getContext("2d");

	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;

	//aggiorna la dimensioni dell'area
	window.onresize = function resize() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		//applica le modifiche
		changeGameState(gameState);
	}

	var mousePoint = new point(0, 0); //conterr√† la posizione del mouse
	var gameState = null;	//stato del gioco
	var keyPressed;
	var title = null;	//titolo del gioco
	var levelRect = null;	//rettangolo del livello
	var backButton = null;
	var levelNumber = 1;	//numero del livello corrente
	var currentLevel = null;	//nome del livello corrente
	var firstLevel = 1;	//numero del primo livello
	var lastLevel = 10; //numero dell'ultimo livello
	var polygon1 = null;

	clearArea();
	//imposto primo stato di gioco
	changeGameState("opening");

	/*
	cambia lo stato del gioco
	*/
	function changeGameState(newState) {
		gameState = newState;
		//inizializza gli oggetti
		initializeObjects();
		//disegna gli oggetti
		startAnimation();
	}

	/*
	pulisce l'area di gioco
	*/
	function clearArea() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.fillStyle = 'rgb(10, 10, 10)'
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	/*
	disegna l'area e gli elementi di gioco
	*/
	function drawArea() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		//pulisco l'area
		clearArea();
		switch (gameState) {
			case "opening":
				title.setText("Start game");
				title.draw(new point(canvas.width*7/16, canvas.height/2), "Serif", false);
				polygon1.draw(new point(canvas.width/2, canvas.height/2));
				break;

			case "levels":
				//aggiorno il nome del livello
				currentLevel = "Level "+levelNumber;
				levelName.setText(currentLevel);
				backButton.setText("Back");
				levelName.draw(new point(canvas.width*15/34, canvas.height*4/5), "Serif");
				levelRect.drawWithLights(new point(canvas.width/6, canvas.height/8));
				levelRect.drawArrowsWithLights();
				backButton.draw(new point(canvas.width/20, canvas.height/15), "Serif", false);
				break;
			case "playing": break;
		}
	}

	/*
	inizializza gli oggetti
	*/
	function initializeObjects() {
		switch (gameState) {
			case "opening":
				title = new writingsRectangle(canvas.height/20, new color(255, 255, 255), new color(0, 255, 0), "Start game");
				polygon1 = new polygon(5, 20, new color(255, 255, 255), new color(255, 0, 0), 5);
				break;
			case "levels":
				//aggiorno il nome del livello
				levelNumber = 1;
				currentLevel = "Level "+levelNumber;
				levelName = new writingsRectangle(canvas.height/20, new color(255, 255, 255), new color(255, 255, 0), currentLevel);
				levelRect = new roundRectangle(canvas.width*2/3, canvas.height*1/2, new color(255, 255, 0));
				backButton = new writingsRectangle(canvas.height/20, new color(255, 255, 255), new color(0, 255, 255), "Back");
				break;
			case "playing": break;
		}
	}

	/*
	avvia le animazioni
	*/
	function startAnimation() {
		switch (gameState) {
			case "opening":
				setInterval(drawArea, 20);
				break;
			case "levels":
				setInterval(drawArea, 20);
				break;
			case "playing": break;
		}
	}

	/*
	Un punto con coordinate x y
	*/
	function point(x, y) {
		this.x = x;
		this.y = y;
	}

	/*
	Oggeto che rappresenta un rettangolo con gli angoli arrotondati
	*/
	function roundRectangle(width, height, shadowColor) {
		this.width = width;
		this.height = height;
		this.shadowColor = shadowColor.makeColor(1);
		this.color = new color(255, 255, 255).makeColor(1);
		this.radius = 10; //raggio degli angoli rotondi
		this.x = null; //x dell'angolo in altro a sx
		this.y = null; //y dell'angolo in altro a sx
		this.arrowOffsetX = null; //distanza delle frecce laterali dal rettangolo
		//vertici delle frecce
		this.leftp1 = null;
		this.leftp2 = null;
		this.leftp3 = null;
		this.rightp1 = null;
		this.rightp2 = null;
		this.rightp3 = null;
		//per mostrare le frecce
		this.showLeftArrow = false;
		this.showRightArrow = true;

		//imposta la largheza del rettangolo
		this.setWidth = function(width) {
			this.width = width;
		}

		/*
		disegna il rettangolo
		@param point: punto di parenza del rettangolo (in altro a sx)
		@param shadows: true per disegnare solo l'ombra
		*/
		this.draw = function(point, shadows) {
			ctx.shadowBlur = 10;
			ctx.shadowColor = this.shadowColor;
			ctx.beginPath();
			ctx.moveTo(this.x + this.radius, this.y);
			ctx.lineTo(this.x + this.width - this.radius, this.y);
			ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + this.radius);
			ctx.lineTo(this.x + this.width, this.y + this.height - this.radius);
			ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - this.radius, this.y + this.height);
			ctx.lineTo(this.x + this.radius, this.y + this.height);
			ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - this.radius);
			ctx.lineTo(this.x, this.y + this.radius);
			ctx.quadraticCurveTo(this.x, this.y, this.x + this.radius, this.y);
			ctx.closePath();
			if (shadows)
				ctx.strokeStyle = this.shadowColor;
			else
				ctx.strokeStyle = this.color;
			ctx.stroke();
		}

		/*
		Disegna il rettangolo (con le ombre se contiene il mouse)
		@param startingPoint: punto di parenza del rettangolo (in altro a sx)
		@return true se il mouse si trova all'interno, false altrimenti
		*/
		this.drawWithLights = function(startingPoint) {
			this.x = startingPoint.x;
			this.y = startingPoint.y;
			var shadows = mouseInRectangle(this.width, this.height, this.x, this.y);
			//se il mouse si trova all'interno del rettangolo disegno le ombre
			if (shadows) {
				this.draw(new point(this.x-this.x/500, this.y+this.y/500), true);
				this.draw(new point(this.x+this.x/500, this.y+this.y/500), true);
			}
			this.draw(startingPoint, false);
			return shadows;
		}

		/*
		Disegna una freccia (trinagolo)
		@param p1, p2, p3: vertici del triangolo
		@param s: offset per disegnare le ombre
		@shadows: true per disegnare l'ombra, false per disegnare il triangolo
		*/
		this.drawArrow = function(p1, p2, p3, s, shadows) {
			ctx.shadowBlur = 10;
			if (shadows)
				ctx.strokeStyle = this.shadowColor;
			else
				ctx.strokeStyle = this.color;
			ctx.shadowColor = this.shadowColor;

			ctx.beginPath();
			ctx.moveTo(p1.x - s, p1.y + s);
			ctx.lineTo(p2.x - s, p2.y + s);
			ctx.lineTo(p3.x - s, p3.y + s);
			ctx.lineTo(p1.x - s, p1.y + s);
			ctx.stroke();
		}

		/*
		Disegna le frecce con le ombre
		*/
		this.drawArrowsWithLights = function() {
			this.arrowOffsetX = this.width/20; 	//distanza delle frecce dai lati del rettangolo e grandezza delle frecce
			//definisco vertici dei trinagoli
			this.leftp1 = new point(this.x - this.arrowOffsetX, this.y + this.height/2 - this.arrowOffsetX);
			this.leftp2 = new point(this.x - this.arrowOffsetX*2, this.y + this.height/2);
			this.leftp3 = new point(this.x - this.arrowOffsetX, this.y + this.height/2 + this.arrowOffsetX);
			this.rightp1 = new point(this.x + this.width + this.arrowOffsetX, this.y + this.height/2 - this.arrowOffsetX);
			this.rightp2 = new point(this.x + this.width + this.arrowOffsetX*2, this.y + this.height/2);
			this.rightp3 = new point(this.x + this.width + this.arrowOffsetX, this.y + this.height/2 + this.arrowOffsetX);

			//disegno le ombre della freccia di sinistra
			if (mouseInTriangle(this.leftp1, this.leftp2, this.leftp3) && this.showLeftArrow) {
				this.drawArrow(this.leftp1, this.leftp2, this.leftp3, this.height/1000, true);
				this.drawArrow(this.leftp1, this.leftp2, this.leftp3, -this.height/1000, true);
			}

			//disegno le ombre della freccia di destra
			if (mouseInTriangle(this.rightp1, this.rightp2, this.rightp3) && this.showRightArrow) {
				this.drawArrow(this.rightp1, this.rightp2, this.rightp3, this.height/1000, true);
				this.drawArrow(this.rightp1, this.rightp2, this.rightp3, -this.height/1000, true)
			}

			//disegno la freccia di sinistra
			if (this.showLeftArrow)
				this.drawArrow(this.leftp1, this.leftp2, this.leftp3, 0, false);

			//disegno la freccia di destra
			if (this.showRightArrow)
				this.drawArrow(this.rightp1, this.rightp2, this.rightp3, 0, false);
		}
	}

	/*
	Oggetto che rappresenta un scritta circondata da un rettangolo
	*/
	function writingsRectangle(size, color, shadowColor, text) {
		this.size = size;
		this.color = color.makeColor(1);
		this.shadowColor = shadowColor.makeColor(1);
		this.text = text;
		this.radius = 10;
		this.wpoint = null;
		this.rpoint = null;
		this.rectWidth = ctx.measureText(text).width*5.3;
		this.rectHeight = this.size*1.5;

		//disegna il rettangolo con la scritta dentro
		this.draw = function(startingPoint, font) {
			this.wpoint = startingPoint;
			this.rpoint = new point(startingPoint.x - this.rectWidth*3/25 , startingPoint.y - this.size);

			ctx.font = this.size+"px "+font;
			ctx.shadowBlur = 10;
			ctx.shadowColor = this.shadowColor;
			ctx.shadowOffsetX = this.size/100;
			ctx.shadowOffsetY = this.size/100;
			if (mouseInRectangle(this.rectWidth, this.rectHeight, this.rpoint.x, this.rpoint.y)) {
				//this.drawLight(x-this.size/600, y-this.size/600);
				//this.drawLight(x+this.size/1200, y+this.size/1200);
				this.drawShadow(new point(this.wpoint.x-this.size/1200, this.wpoint.y+this.size/1200));
				this.drawShadow(new point(this.wpoint.x+this.size/1200, this.wpoint.y-this.size/1200));
				this.drawRect(true);
				this.drawRect(true);
			}
			ctx.strokeStyle = this.color;
			ctx.strokeText(this.text, this.wpoint.x, this.wpoint.y);
			this.drawRect(false);

		}

		//disegna l'ombra
		this.drawShadow = function(point) {
			ctx.shadowColor = this.shadowColor;
			ctx.strokeStyle = this.shadowColor;
			ctx.strokeText(this.text, point.x, point.y);
		}

		//disegna il rettangolo
		this.drawRect = function(shadows) {
			ctx.shadowBlur = 10;
			ctx.shadowColor = this.shadowColor;
			ctx.beginPath();
			ctx.moveTo(this.rpoint.x + this.radius, this.rpoint.y);
			ctx.lineTo(this.rpoint.x + this.rectWidth - this.radius, this.rpoint.y);
			ctx.quadraticCurveTo(this.rpoint.x + this.rectWidth, this.rpoint.y, this.rpoint.x + this.rectWidth, this.rpoint.y + this.radius);
			ctx.lineTo(this.rpoint.x + this.rectWidth, this.rpoint.y + this.rectHeight - this.radius);
			ctx.quadraticCurveTo(this.rpoint.x + this.rectWidth, this.rpoint.y + this.rectHeight, this.rpoint.x + this.rectWidth - this.radius, this.rpoint.y + this.rectHeight);
			ctx.lineTo(this.rpoint.x + this.radius, this.rpoint.y + this.rectHeight);
			ctx.quadraticCurveTo(this.rpoint.x, this.rpoint.y + this.rectHeight, this.rpoint.x, this.rpoint.y + this.rectHeight - this.radius);
			ctx.lineTo(this.rpoint.x, this.rpoint.y + this.radius);
			ctx.quadraticCurveTo(this.rpoint.x, this.rpoint.y, this.rpoint.x + this.radius, this.rpoint.y);
			ctx.closePath();
			if (shadows)
				ctx.strokeStyle = this.shadowColor;
			else
				ctx.strokeStyle = this.color;
			ctx.stroke();
		}

		//imposta il testo e ricalcola la larghezza del rettangolo
		this.setText = function(text) {
			this.text = text;
			this.rectWidth = ctx.measureText(text).width*this.size*3/25;
		}
	}

	function polygon(sides, size, color, shadowColor, rv) {
		this.sides = sides;
		this.side = size;
		this.color = color.makeColor(1);
		this.shadowColor = shadowColor.makeColor(1);
		this.rotation = 0;
		this.rv = rv;

		this.draw = function(center) {
			ctx.strokeStyle = this.color;
			ctx.shadowColor = this.shadowColor;
			this.shadowBlur = 10;
			ctx.beginPath();
			ctx.moveTo(center.x + size * Math.cos(0 + this.rotation), center.y + size * Math.sin(0 + this.rotation));
			for (var i=0; i<sides; i++) {
				ctx.lineTo(center.x + size * Math.cos(i * 2 * Math.PI / sides) + this.rotation, center.y + size * Math.sin(i * 2 * Math.PI / sides) + this.rotation);
			}
			ctx.closePath();
			ctx.stroke();
			this.rotation = (this.rotation + this.rv) % (Math.Pi * 2);
		}
	}

	/*
	oggetto per generare colori
	*/
	function color(red, green, blue) {
		this.red = red;
		this.green = green;
		this.blue = blue;
		this.hex = red.toString(16)+green.toString(16)+blue.toString(16);
		this.color = "rgba(0, 0, 0, 0)";

		this.makeColor = function(opacity) {
			this.color = "rgba("+red+", "+green+", "+blue+", "+opacity+")";
			return this.color;
		}

		this.makeHexColor = function() {
			return "#"+this.hex;
		}
	}

	/*
	salva l'ultimo tasto premuto
	*/
	function keyPressed(event) {
		keyPressed = event.keyCode();
	}

	/*
	aggiorna la posizione del muose quando si muove
	*/
	function updateMouseCoordinates(event) {
		mousePoint = new point(event.clientX, event.clientY);
	}

	/*
	Gestisce l'evento mouseClick
	*/
	function mouseClick() {
		switch(gameState) {
			case "opening":
				//con il click su "Start game" passo ai livelli
				if (mouseInRectangle(title.rectWidth, title.rectHeight, title.rpoint.x, title.rpoint.y)) {
					changeGameState("levels");
				}
			break;
			case "levels":
				//click sulla freccia di sinistra, passa al livello precedente
				if (mouseInTriangle(levelRect.leftp1, levelRect.leftp2, levelRect.leftp3)) {
					if (levelNumber > firstLevel) {
						levelNumber--;
						updateArrows();
						drawArea();
					}
				}
				//click sulla freccia di destra, passa al prossimo livello
				else if (mouseInTriangle(levelRect.rightp1, levelRect.rightp2, levelRect.rightp3)) {
					if (levelNumber < lastLevel) {
						levelNumber++;
						updateArrows();
						drawArea();
					}
				}
				//click sul bottone back
				else if (mouseInRectangle(backButton.rectWidth, backButton.rectHeight, backButton.rpoint.x, backButton.rpoint.y)) {
					changeGameState("opening");
				}
				break;
			case "playing":
				break
		}
	}

	/*
	Imposta le frecce da mostrare
	*/
	function updateArrows() {
		switch(levelNumber) {
			//primo livello, solo freccia a dx
			case firstLevel:
				levelRect.showLeftArrow = false;
				levelRect.showRightArrow = true;
				break;
			//ultimo livello, solo freccia a sx
			case lastLevel:
				levelRect.showLeftArrow = true;
				levelRect.showRightArrow = false;
				break;
			default:
				levelRect.showLeftArrow = true;
				levelRect.showRightArrow = true;
		}
	}

	/*
	Controlla se il mouse si trova nel rettangolo
	@return: true se il mouse si trova all'interno, false altrimenti
	*/
	function mouseInRectangle(width, height, x, y) {
		if (mousePoint.x >= x && mousePoint.x <= x + width && mousePoint.y >= y && mousePoint.y <= y + height) {
			return true;
		}
		else
			return false;
	}

	/*
	TODO: why?
	*/
	function sign(point1, point2, point3) {
		return (point1.x - point3.x)*(point2.y - point3.y)-(point2.x - point3.x)*(point1.y - point3.y);
	}

	/*
	Controlla se il mouse si trova all'interno del triangolo
	@return: true se il mouse si trova all'interno, false altrimenti
	*/
	function mouseInTriangle(point1, point2, point3) {
		var d1 = sign(mousePoint, point1, point2);
		var d2 = sign(mousePoint, point2, point3);
		var d3 = sign(mousePoint, point3, point1);

		var hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
		var hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

		return !(hasNeg && hasPos);
	}
</script>
</body>
</html>
