<!DOCTYPE html>
<html>
<head>
	<title>test</title>
</head>
<style type="text/css">
	html, body {
			width: 100%;
			height: 100%;
			margin: 0px;
			overflow: hidden;
	}
	canvas {
		width: 100%;
		height: 100%;
		margin-bottom: 0px;
	}
</style>
<body>
<canvas id="canvas" onmousemove="updateMouseCoordinates(event)" onkeypress="keyPressed(event)" onclick="mouseClick()"> </canvas>
<script type="text/javascript">
	canvas = document.getElementById("canvas");
	ctx = canvas.getContext("2d");

	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;

	window.onresize = function resize() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		changeGameState(gameState);
	}

	//TODO: make unique object for writings inside a rectangle

	var mousePoint = new point(0, 0);
	var gameState = null;
	var keyPressed;
	var title = null;
	var titleRect = null;
	var levelNameRect = null;
	var levelRect = null;
	var levelNumber = 1;
	var currentLevel = null;

	changeGameState("opening");

	/*
	cambia lo stato del gioco
	*/
	function changeGameState(newState) {
		gameState = newState;
		clearArea();
		initializeObjects();
		startAnimation();
	}

	/*
	pulisce l'area di gioco
	*/
	function clearArea() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.fillStyle = 'rgb(10, 10, 10)'
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	/*
	disegna l'area e gli elementi di gioco
	*/
	function drawArea() {
		clearArea();
		switch (gameState) {
			case "opening":
				var titlePoint = new point(canvas.width*7/16, canvas.height/2);
				var rectPoint = new point(titlePoint.x-title.size/10, titlePoint.y-title.size);
				var lights = titleRect.drawWithLights(rectPoint);
				title.draw(titlePoint, lights, "Serif");
				break;

			case "levels":
				var levelNamePoint = new point(canvas.width*15/34, canvas.height*4/5);
				var lights = levelNameRect.drawWithLights(new point(levelNamePoint.x-levelName.size/10, levelNamePoint.y-levelName.size));
				levelName.draw(levelNamePoint, lights, "Serif");
				levelRect.drawWithLights(new point(canvas.width/6, canvas.height/8));
				levelRect.drawArrowsWithLights();
				break;
			case "playing": break;
		}
	}

	/*
	inizializza gli oggetti
	*/
	function initializeObjects() {
		switch (gameState) {
			case "opening":
				title = new neonString(new Color(255, 255, 255), new Color(0, 255, 0), canvas.height/20, "Start game");
				titleRect = new roundRectangle(ctx.measureText(title.text).width*title.size/10.8, title.size*1.5, new Color(0, 255, 0));
				break;
			case "levels":
				currentLevel = "Level "+levelNumber;
				levelName = new neonString(new Color(255, 255, 255), new Color(255, 255, 0), canvas.height/20, currentLevel);
				//TODO: rettangolo lunghissimo quando si cambia stato
				levelNameRect = new roundRectangle(ctx.measureText(levelName.text).width*levelName.size/10, levelName.size*1.5, new Color(255, 255, 0));
				levelRect = new roundRectangle(canvas.width*2/3, canvas.height*1/2, new Color(255, 255, 0));
				break;
			case "playing": break;
		}
	}

	/*
	imposta i listener per mouse e tastiera
	*/
	function startAnimation() {
		switch (gameState) {
			case "opening":
				setInterval(drawArea, 20);
				break;
			case "levels":
				setInterval(drawArea, 20);
				break;
			case "playing": break;
		}
	}

	function point(x, y) {
		this.x = x;
		this.y = y;
	}

	function roundRectangle(width, height, shadowColor) {
		this.width = width;
		this.height = height;
		this.shadowColor = shadowColor.makeColor(1);
		this.color = new Color(255, 255, 255).makeColor(1);
		this.radius = 10;
		this.x = null;
		this.y = null;
		this.arrowOffsetX = null;

		this.draw = function(point, shadows) {
			ctx.shadowBlur = 10;
			ctx.shadowColor = this.shadowColor;
			ctx.beginPath();
			ctx.moveTo(this.x + this.radius, this.y);
			ctx.lineTo(this.x + this.width - this.radius, this.y);
			ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + this.radius);
			ctx.lineTo(this.x + this.width, this.y + this.height - this.radius);
			ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - this.radius, this.y + this.height);
			ctx.lineTo(this.x + this.radius, this.y + this.height);
			ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - this.radius);
			ctx.lineTo(this.x, this.y + this.radius);
			ctx.quadraticCurveTo(this.x, this.y, this.x + this.radius, this.y);
			ctx.closePath();
			if (shadows)
				ctx.strokeStyle = this.shadowColor;
			else
				ctx.strokeStyle = this.color;
			ctx.stroke();
		}

		this.drawWithLights = function(startingPoint) {
			this.x = startingPoint.x;
			this.y = startingPoint.y;
			var shadows = mouseInRectangle(this.width, this.height, this.x, this.y);
			if (shadows) {
				this.draw(new point(this.x-this.x/500, this.y+this.y/500), true);
				this.draw(new point(this.x+this.x/500, this.y+this.y/500), true);
			}
			this.draw(startingPoint, false);
			return shadows;
		}

		this.drawArrow = function(p1, p2, p3, s, shadows) {
			ctx.shadowBlur = 10;
			if (shadows)
				ctx.strokeStyle = this.shadowColor;
			else
				ctx.strokeStyle = this.color;
			ctx.shadowColor = this.shadowColor;

			//freccia a sinistra
			ctx.beginPath();
			ctx.moveTo(p1.x - s, p1.y + s);
			ctx.lineTo(p2.x - s, p2.y + s);
			ctx.lineTo(p3.x - s, p3.y + s);
			ctx.lineTo(p1.x - s, p1.y + s);
			ctx.stroke();
		}

		this.drawArrowsWithLights = function() {
			this.arrowOffsetX = this.width/20;
			var leftp1 = new point(this.x - this.arrowOffsetX, this.y + this.height/2 - this.arrowOffsetX);
			var leftp2 = new point(this.x - this.arrowOffsetX*2, this.y + this.height/2);
			var leftp3 = new point(this.x - this.arrowOffsetX, this.y + this.height/2 + this.arrowOffsetX);
			var rightp1 = new point(this.x + this.width + this.arrowOffsetX, this.y + this.height/2 - this.arrowOffsetX);
			var rightp2 = new point(this.x + this.width + this.arrowOffsetX*2, this.y + this.height/2);
			var rightp3 = new point(this.x + this.width + this.arrowOffsetX, this.y + this.height/2 + this.arrowOffsetX);

			if (mouseInTriangle(leftp1, leftp2, leftp3)) {
				this.drawArrow(leftp1, leftp2, leftp3, this.height/1000, true);
				this.drawArrow(leftp1, leftp2, leftp3, -this.height/1000, true);
			}
			if (mouseInTriangle(rightp1, rightp2, rightp3)) {
				this.drawArrow(rightp1, rightp2, rightp3, this.height/1000, true);
				this.drawArrow(rightp1, rightp2, rightp3, -this.height/1000, true)
			}
			this.drawArrow(leftp1, leftp2, leftp3, 0, false);
			this.drawArrow(rightp1, rightp2, rightp3, 0, false);
		}
	}

	/*
	oggetto per generare colori
	*/
	function Color(red, green, blue) {
		this.red = red;
		this.green = green;
		this.blue = blue;
		this.hex = red.toString(16)+green.toString(16)+blue.toString(16);
		this.color = "rgba(0, 0, 0, 0)";

		this.makeColor = function(opacity) {
			this.color = "rgba("+red+", "+green+", "+blue+", "+opacity+")";
			return this.color;
		}

		this.makeHexColor = function() {
			return "#"+this.hex;
		}
	}

	/*
	stringa con effetto neon
	*/
	function neonString(color, shadowColor, size, text) {
		this.color = color.makeColor(1);
		this.shadowColor = shadowColor.makeColor(1);
		this.text = text;
		this.x = null;
		this.y = null;
		this.size = size;

		this.draw = function(startingPoint, lights, font) {
			this.x = startingPoint.x;
			this.y = startingPoint.y;
			ctx.font = this.size+"px "+font;
			ctx.shadowBlur = 10;
			ctx.shadowColor = this.shadowColor;
			ctx.shadowOffsetX = this.size/100;
			ctx.shadowOffsetY = this.size/100;
			if (lights) {
				//this.drawLight(x-this.size/600, y-this.size/600);
				//this.drawLight(x+this.size/1200, y+this.size/1200);
				this.drawLight(new point(this.x-this.size/1200, this.y+this.size/1200));
				this.drawLight(new point(this.x+this.size/1200, this.y-this.size/1200));
			}
			ctx.strokeStyle = this.color;
			ctx.strokeText(this.text, this.x, this.y);
		}

		this.drawLight = function(point) {
			ctx.shadowColor = this.shadowColor;
			ctx.strokeStyle = this.shadowColor;
			ctx.strokeText(this.text, point.x, point.y);
		}
	}

	/*
	salva l'ultimo tasto premuto
	*/
	function keyPressed(event) {
		keyPressed = event.keyCode();
	}

	/*
	aggiorna la posizione del muose quando si muove
	*/
	function updateMouseCoordinates(event) {
		mousePoint = new point(event.clientX, event.clientY);
	}

	function mouseClick() {
		switch(gameState) {
			case "opening":
				//con il click su "Start game" passo ai livelli
				if (mouseInRectangle(titleRect.width, titleRect.height, titleRect.x, titleRect.y)) {
					gameState = "levels";
					changeGameState("levels");
				}
			break;
			case "levels":
				break;
			case "playing":
				break
		}
	}

	function mouseInRectangle(width, height, x, y) {
		if (mousePoint.x >= x && mousePoint.x <= x + width && mousePoint.y >= y && mousePoint.y <= y + height) {
			return true;
		}
		else
			return false;
	}

	function sign(point1, point2, point3) {
		return (point1.x - point3.x)*(point2.y - point3.y)-(point2.x - point3.x)*(point1.y - point3.y);
	}

	function mouseInTriangle(point1, point2, point3) {
		var d1 = sign(mousePoint, point1, point2);
		var d2 = sign(mousePoint, point2, point3);
		var d3 = sign(mousePoint, point3, point1);

		var hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
		var hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

		return !(hasNeg && hasPos);
	}

</script>
</body>
</html>
