<!DOCTYPE html>
<html>
<head>
	<title>Progetto di Interfacce</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<meta charset="utf-8"/>
<body>
	<div class="container" style="background-color: #333333">

		<canvas id="canvas" width="900" height="600" onkeydown="keyPressed(event)" onclick="mouseClick()" onmousedown="mouseDown()" onmouseup="mouseUp()">
		</canvas>
		<button class="startButton" id="startButton">
			<div class="startText" id="startText">Start</div>
		</button>
		<button class="backButton" id="backButton">
			<div class="backText" id="backText">Back</div>
		</button>
		<button class="tryButton" id="tryButton">
			<div class="tryText" id="tryText">Try</div>
		</button>
		<script type="text/javascript" src="./Utils.js"></script>
		<script type="text/javascript" src="./Collisions.js"></script>
		<script type="text/javascript" src="./Elements.js"></script>
		<script type="text/javascript">
			var canvas = document.getElementById("canvas");
			var ctx = canvas.getContext("2d");
			document.onkeydown = keyPressed;

			var startButton = document.querySelector(".startButton");
			var backButton = document.querySelector(".backButton");
			var tryButton = document.querySelector(".tryButton");
			hideButtons("editor");


			function hideButtons(gameState) {
				if (gameState == "opening")
					startButton.style.display='none';
				if (gameState =="editor") {
					backButton.style.display='none';
					tryButton.style.display='none';
				}
			}

			function showButtons(gameState) {
				if (gameState == "opening")
					startButton.style.display='block';
				if (gameState =="editor") {
					backButton.style.display='block';
					tryButton.style.display='block';
				}
			}

			function setStartListener() {
				startButton.addEventListener("click", function clickS(e) {
					startButton.removeEventListener("click", clickS);
					hideButtons("opening");
					showButtons("editor");
					changeGameState("editor");
				});
			};

			function setEditorListeners() {
				backButton.addEventListener("click", function clickB(e) {
					backButton.removeEventListener("click", clickB);
					hideButtons("editor");
					showButtons("opening");
					changeGameState("opening");
				});
				tryButton.addEventListener("click", function clickT(e) {
					tryButton.removeEventListener("click", clickT);
					hideButtons("editor");
					changeGameState("playing");
				});
			};

			canvas.addEventListener("mousemove", function mouseMove(event) {
				updateMouseCoordinates(event);
			});

			var mousePoint = new point(0, 0); //conterrà la posizione del mouse
			var gameState = null;	//stato del gioco
			var keyPressed;
			var choosedPolygon = null;
			var rectangleEditor = null;
			var polygons = [];
			var myBall = null;
			var myBallCenter = new point(canvas.width*11/12, canvas.height/2);
			var animation = null;
			var backgroundColor = new color(30, 30, 30).makeColor(1);
			var backgroundColor2 = new color(10, 10, 10).makeColor(1);
			var gravity = 0;
			var bounce = -0.9;
			var ballClicked = false;
			var shotPoint = null;
			var dragging = false;
			var draggingIndex = -1;
			var placedPolygons = [];
			var draggingBall = false;
			var ballColliding = false;
			var placedCenters = [];
			var draggedPolygon = null;
			var npp = 0;
			var vIndex = -1;

			clearArea();
			//imposto primo stato di gioco
			changeGameState("opening");

			window.addEventListener('wheel', function(event) {
				for (var i=0; i<placedPolygons.length; i++) {
					if (placedPolygons[i] && contains(placedPolygons[i], mousePoint)) {
						if (event.deltaY < 0 && placedPolygons[i].size >= 20) {
							placedPolygons[i].size -= 5;
						}
						if (event.deltaY > 0 && placedPolygons[i].size <= 70) {
							placedPolygons[i].size += 5;
						}
					}
				}
			});

			/*
			cambia lo stato del gioco
			*/
			function changeGameState(newState) {
				if (gameState == null || newState != gameState) {
					var oldState = gameState;
					gameState = newState;
					//inizializza gli oggetti
					initializeObjects();
					if (gameState == "opening") {
						setStartListener();
					}
					if (gameState == "editor") {
						if (oldState == "playing") {
							for (var i=0; i<placedPolygons.length; i++) {
								if (placedPolygons[i] != null) {
									placedCenters[i].x = placedCenters[i].x*2/3 + canvas.width/6;
									placedCenters[i].y = placedCenters[i].y*2/3 + canvas.height/6;
									placedPolygons[i].size *= 2/3;
								}
							}
							myBallCenter = myBall.center;
						}
						setEditorListeners();
						showButtons("editor");
					}
					if (gameState == "playing") {
						for (var i=0; i<placedPolygons.length; i++) {
							if (placedPolygons[i] != null) {
								placedCenters[i].x = (placedCenters[i].x - canvas.width/6)*3/2;
								placedCenters[i].y = (placedCenters[i].y - canvas.height/6)*3/2;
								placedPolygons[i].size *= 3/2;
							}
						}
						myBall.center.x = (myBall.center.x - canvas.width/6)*3/2;
						myBall.center.y = (myBall.center.y - canvas.height/6)*3/2;
					}
				}
				//disegna gli oggetti
				startAnimation();
				}

			/*
			pulisce l'area del canvas
			*/
			function clearArea() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = backgroundColor2;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
			}

			/*
			disegna l'area e gli elementi di gioco
			*/
			function drawArea() {
				//pulisco l'area
				clearArea();
				switch (gameState) {
					case "opening":
						polygons[0].drawWithLights(new point(canvas.width/10, canvas.width/10));
						polygons[1].drawWithLights(new point(canvas.width/5, canvas.width/5));
						bouncePolygons();
						break;

					case "editor":
						for (var i=0; i<polygons.length; i++) {
							polygons[i].drawWithLights(new point(canvas.width/12, canvas.height*(3+i)/9));
						}
						if (dragging)
							draggedPolygon.drawWithLights(mousePoint);
						myBall.drawWithLights();
						for (var i=0; i<placedPolygons.length; i++) {
							if (i != draggingIndex && placedPolygons[i] != null)
								placedPolygons[i].drawWithLights(placedCenters[i]);
								result = detectCircleShapeCollision(myBall.center, myBall.radius, placedPolygons[i]);
						}
						rectangleEditor.drawWithLights(new point(canvas.width/6, canvas.height/6));
						break;

					case "playing":
						for (var i=0; i<placedPolygons.length; i++) {
							if (placedPolygons[i] != null) {
								placedPolygons[i].drawWithLights(placedCenters[i]);
							}
						}
						myBall.drawWithLights();
						var nextCenter = new point(myBall.center.x + myBall.vx, myBall.center.y + myBall.vy);
						for (var i=0; i<placedPolygons.length; i++) {
							if (placedPolygons[i] != null) {
								result = detectCircleShapeCollision(nextCenter, myBall.radius, placedPolygons[i]);
								if (result.overlaps == true) {
									//if (result.p != null) {
										//pushOut(result.closestPoint, myBall);
										updateV(myBall, result.p, result.elength, result.isInside);
									//}
								}
							}
						}
						break;
				}
			}

			/*
			inizializza gli oggetti
			*/
			function initializeObjects() {
				switch (gameState) {
					case "opening":
						clearPolygons();
						polygons[0] = new polygon(Math.floor(Math.random()*3)+3, Math.random()*20+30, new color(255, 255, 255),
																			new color(50+Math.random()*205, 50+Math.random()*205, 50+Math.random()*205), 0, 1.5, 1.5, -0.2);
						polygons[1] = new polygon(Math.floor(Math.random()*3)+3, Math.random()*20+30, new color(255, 255, 255),
																			new color(50+Math.random()*205, 50+Math.random()*205, 50+Math.random()*205), 0, -1.5, -1.5, 0.5);
						break;
					case "editor":
						clearPolygons();
						rectangleEditor = new roundRectangle(canvas.width*2/3, canvas.height*2/3, new color(255, 0, 0));
						for (var i=0; i<4; i++) {
							polygons[i] = new polygon(3+i, 30, new color(255, 255, 255), new color(255, 0, 255), Math.PI*3/2, 0, 0, 0);
						}
						myBall = new ball(myBallCenter, 15, new color(255, 255, 255), new color(0, 255, 0), 0, 0);
						gravity = 0;

						break;
					case "playing":
						clearPolygons();
						myBall = new ball(myBallCenter, 15, new color(255, 255, 255), new color(0, 255, 0), 0, 0);
						break;
				}
			}

			/*
			avvia le animazioni
			*/
			function startAnimation() {
				clearInterval(animation);
				switch (gameState) {
					case "opening":
						animation = setInterval(drawArea, 20);
						break;
					case "editor":
						animation = setInterval(drawArea, 20);
						break;
					case "playing":
						animation = setInterval(drawArea, 20);
		 				break;
				}
			}

			/*
			salva l'ultimo tasto premuto
			*/
			function keyPressed(event) {
				key = event.keyCode;
				if (gameState == "playing") {
					if (key == 27) {
						changeGameState("editor");
					}
				}
				if (gameState == "editor") {
					for (var i=0; i<placedPolygons.length; i++) {
						if (placedPolygons[i] != null && contains(placedPolygons[i], mousePoint)) {
							if (key == 37)
								placedPolygons[i].rotation += Math.PI/12;
							if (key == 39)
								placedPolygons[i].rotation -= Math.PI/12;
						}
					}
				}
			}

			/*
			aggiorna la posizione del muose quando si muove
			*/
			function updateMouseCoordinates(event) {
				mousePoint = findRelativeCoordinates(event.clientX, event.clientY);
				if (gameState == "editor" && draggingBall) {
					myBall.center = mousePoint;
					for (var i=0; i<placedPolygons.length; i++) {
						if (placedPolygons[i] != null && detectCircleShapeCollision(myBall.center, myBall.radius, placedPolygons[i]).overlaps == true) {
							myBall.changeShadowColor(new color(0, 0, 255));
							ballColliding = true;
							break;
						}
						else {
							myBall.changeShadowColor(new color(0, 255, 0));
							ballColliding = false;
						}
					}
				}
			}

			/*
			Gestisce l'evento mouseClick
			*/
			function mouseClick() {
				switch(gameState) {
					case "editor":
					 for(var i=0; i<placedPolygons.length; i++) {
						 if ( placedPolygons[i] != null && contains(placedPolygons[i], mousePoint)) {
							 choosedPolygon = clonePolygon(placedPolygons[i]);
						 }
					 }
					break;
				}
			}

			function mouseDown() {
				if (gameState == "playing") {
					if (mouseInCircle(myBall)) {
						ballClicked = true;
					}
					myBall.line = true;
				}
				if (gameState == "editor") {
					for (var i=0; i<polygons.length; i++) {
						if (contains(polygons[i], mousePoint)) {
							dragging = true;
							draggingIndex = -1;
							draggedPolygon = clonePolygon(polygons[i]);
							break;
						}
					}
					for (var i=0; i<placedPolygons.length; i++) {
						if (placedPolygons[i] && contains(placedPolygons[i], mousePoint)) {
							dragging = true;
							draggingIndex = i;
							draggedPolygon = clonePolygon(placedPolygons[i]);
						}
					}
					if (mouseInCircle(myBall)) {
						draggingBall = true;
					}
				}
			}

			function mouseUp() {
				if (gameState == "editor") {
					if (dragging) {
						if (mouseInRectangle(rectangleEditor)) {
							if (draggingIndex == -1) {
								//sto trascianndo un nuovo poligono
								placedPolygons[npp] = clonePolygon(draggedPolygon);
								placedCenters[npp] = mousePoint;
								npp = findFreeSpot();
							}
							else {
								//sto trascinando un poligono già piazzato
								placedCenters[draggingIndex] = mousePoint;
								draggingIndex = -1;
							}
						}
						//ho trascinato un poligono fuori dal rettangolo
						else if (draggingIndex != -1) {
							placedPolygons[draggingIndex] = null;
							placedCenters[draggingIndex] = null;
							npp = findFreeSpot();
						}
						draggedPolygon = null;
						dragging = false;
					}
					if (draggingBall) {
						if (!mouseInRectangle(rectangleEditor, mousePoint) || ballColliding) {
							myBall.center = new point(canvas.width*11/12, canvas.height/2);

							myBall.changeShadowColor(new color(0, 255, 0));
						}
						myBallCenter = myBall.center;
						draggingBall = false;
					}
				}
				if (gameState == "playing") {
					if (ballClicked == true) {
						shotPoint = mousePoint;
						var vx = shotPoint.x - myBall.center.x;
						var vy = shotPoint.y - myBall.center.y;
						var v = new vector(shotPoint.x - myBall.center.x, shotPoint.y - myBall.center.y).normalize();
						myBall.setSpeed(-v.x*30, -v.y*30);
						ballClicked = false;
						gravity = 0;
					}
					myBall.line = false;
				}
			}

			function clearPolygons() {
				polygons = null;
				polygons = [];
			}

			function findFreeSpot() {
				place = -1;
				for (var i=0; i<placedPolygons.length; i++) {
					if (placedPolygons[i] == null)
						place = i;
				}
				if (place == -1) {
					place = placedPolygons.length;
				}
				return place;
			}
		</script>
	</div>
</body>
</html>
